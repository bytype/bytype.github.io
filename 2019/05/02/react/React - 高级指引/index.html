<!DOCTYPE html><html lang="cn" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>React - 高级指引 | Jassica</title><meta name="keywords" content="React"><meta name="author" content="刘俊宏"><meta name="copyright" content="刘俊宏"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="代码分割打包 大多数 React 应用都会使用 Webpack、Rollup、Browserify 这类构建工具打包文件 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”  代码分割 打包器 Rollup Webpack Browserify factor-bundle 能够创建多个包并在运行时动态加载   引入代码分割的最佳方式是动态 import()  1234&#x2F;">
<meta property="og:type" content="article">
<meta property="og:title" content="React - 高级指引">
<meta property="og:url" content="http://example.com/2019/05/02/react/React%20-%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95/index.html">
<meta property="og:site_name" content="Jassica">
<meta property="og:description" content="代码分割打包 大多数 React 应用都会使用 Webpack、Rollup、Browserify 这类构建工具打包文件 打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”  代码分割 打包器 Rollup Webpack Browserify factor-bundle 能够创建多个包并在运行时动态加载   引入代码分割的最佳方式是动态 import()  1234&#x2F;">
<meta property="og:locale">
<meta property="og:image" content="https://byblog.oss-cn-hangzhou.aliyuncs.com/4.jpeg">
<meta property="article:published_time" content="2019-05-01T16:00:00.000Z">
<meta property="article:modified_time" content="2022-06-13T07:47:10.308Z">
<meta property="article:author" content="刘俊宏">
<meta property="article:tag" content="React">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://byblog.oss-cn-hangzhou.aliyuncs.com/4.jpeg"><link rel="shortcut icon" href="https://byblog.oss-cn-hangzhou.aliyuncs.com/avatar.jpg"><link rel="canonical" href="http://example.com/2019/05/02/react/React%20-%20%E9%AB%98%E7%BA%A7%E6%8C%87%E5%BC%95/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'React - 高级指引',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-13 15:47:10'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://byblog.oss-cn-hangzhou.aliyuncs.com/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">0</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://byblog.oss-cn-hangzhou.aliyuncs.com/4.jpeg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Jassica</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">React - 高级指引</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">Created</span><time datetime="2019-05-01T16:00:00.000Z" title="Created 2019-05-02 00:00:00">2019-05-02</time></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><ul>
<li>大多数 React 应用都会使用 Webpack、Rollup、Browserify 这类构建工具打包文件</li>
<li>打包是一个将文件引入并合并到一个单独文件的过程，最终形成一个 “bundle”</li>
</ul>
<h2 id="代码分割-1"><a href="#代码分割-1" class="headerlink" title="代码分割"></a>代码分割</h2><ul>
<li>打包器 <a target="_blank" rel="noopener" href="https://rollupjs.org/guide/en/#code-splitting">Rollup</a><ul>
<li><a target="_blank" rel="noopener" href="https://webpack.docschina.org/guides/code-splitting/">Webpack</a></li>
<li>Browserify</li>
<li><a target="_blank" rel="noopener" href="https://github.com/browserify/factor-bundle">factor-bundle</a> 能够创建多个包并在运行时动态加载</li>
</ul>
</li>
<li>引入代码分割的最佳方式是动态 import()</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Webpack 解析该语法时，会自动进行代码分割</span></span><br><span class="line"><span class="title function_">import</span>(<span class="string">&quot;./math&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(math.<span class="title function_">add</span>(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用 Babel 时，确保 Babel 能够解析动态 import 语法而不是将其转换。对于这一要求需要 babel-plugin-syntax-dynamic-import 插件</li>
</ul>
<h2 id="React-lazy"><a href="#React-lazy" class="headerlink" title="React.lazy"></a>React.lazy</h2><ul>
<li>React.lazy 函数能像渲染常规组件一样处理动态引入（的组件）</li>
<li>想要在使用服务端渲染的应用中使用，推荐 <a target="_blank" rel="noopener" href="https://github.com/gregberge/loadable-components">Loadable Components</a> 这个库，它有一个很棒的服务端渲染打包指南</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Suspense</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// React.lazy 接受一个函数(需要动态调用 import()).它必须返回一个 Promise，该 Promise 需要 resolve 一个 defalut export 的 React 组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">OtherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./OtherComponent&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">AnotherComponent</span> = <span class="title class_">React</span>.<span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./AnotherComponent&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// fallback 属性接受任何在组件加载过程中展示的 React 元素</span></span><br><span class="line"><span class="comment">// Suspense 组件中渲染 lazy 组件，可以使用在等待加载 lazy 组件时做优雅降级（loading 等操作）</span></span><br><span class="line"><span class="comment">// Suspense 组件可以置于懒加载组件之上的任何位置，它可以包裹多个懒加载组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">OtherComponent</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">AnotherComponent</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;/<span class="name">section</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于路由的代码分割"><a href="#基于路由的代码分割" class="headerlink" title="基于路由的代码分割"></a>基于路由的代码分割</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 React.lazy 和 React Router 这类的第三方库，来配置基于路由的代码分割</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;<span class="title class_">Suspense</span>, lazy&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">BrowserRouter</span> <span class="keyword">as</span> <span class="title class_">Router</span>, <span class="title class_">Route</span>, <span class="title class_">Switch</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Home</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./routes/Home&#x27;</span>));</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">About</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="title function_">import</span>(<span class="string">&#x27;./routes/About&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">div</span>&gt;</span>Loading...<span class="tag">&lt;/<span class="name">div</span>&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><h2 id="何时用-Context"><a href="#何时用-Context" class="headerlink" title="何时用 Context"></a>何时用 Context</h2><ul>
<li>Context 提供一种在组件之间共享此类值的方式，不必显式地通过组件树逐层传递 props</li>
<li>应用场景：很多不同层级的组件需要访问同样的数据，<code>谨慎使用，因为这会使得组件的复用性变差</code>，包括管理当前的 locale、theme、或者一些缓存数据</li>
<li>如果只是想避免层层传递一些属性，组件组合（component composition）有时是比 context 更好的解决方案</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context 可以让我们无须明确地传遍每一个组件，就能将值深入传递进组件树。</span></span><br><span class="line"><span class="comment">// 为当前的 theme 创建一个 context（“light”为默认值）。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="string">&#x27;light&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 使用一个 Provider 来将当前的 theme 传递给以下的组件树。</span></span><br><span class="line">        <span class="comment">// 无论多深，任何组件都能读取这个值。</span></span><br><span class="line">        <span class="comment">// 在这个例子中，我们将 “dark” 作为当前的值传递下去。</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Provider</span> <span class="attr">value</span>=<span class="string">&quot;dark&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Toolbar</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">ThemeContext.Provider</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间的组件再也不必指明往下传递 theme 了。</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Toolbar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">ThemedButton</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThemedButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// 指定 contextType 读取当前的 theme context。</span></span><br><span class="line">    <span class="comment">// React 会往上找到最近的 theme Provider，然后使用它的值。</span></span><br><span class="line">    <span class="comment">// 在这个例子中，当前的 theme 值为 “dark”。</span></span><br><span class="line">    <span class="keyword">static</span> contextType = <span class="title class_">ThemeContext</span>;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Button</span> <span class="attr">theme</span>=<span class="string">&#123;this.context&#125;/</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><ul>
<li>React.createContext</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React 渲染订阅Context 对象的组件，组件会从组件树中离自身最近匹配的 Provider 中读取到当前的 context 值</span></span><br><span class="line"><span class="comment">// 只有组件所处的树中没有匹配到 Provider ，其 defaultValue 参数才会生效</span></span><br><span class="line"><span class="comment">// 将 undefined 传递给 Provider 的 value 时，消费组件的 defaultValue 不会生效</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure>

<ul>
<li>Context.Provider<ul>
<li>每个 Context 对象都会返回一个 Provider React 组件，它允许消费组件订阅 context 的变化</li>
<li>Provider 接收一个 value 属性，传递给消费组件</li>
<li>一个 Provider 可以和多个消费组件有对应关系。多个 Provider 也可以嵌套使用，里层的会覆盖外层的数据</li>
<li>value 变化时，它内部所有消费组件都会重新渲染</li>
<li>Provider 及其内部 consumer 组件都不受制于 <code>shouldComponentUpdate</code> 函数，当 consumer 组件在其祖先组件退出更新的情况下也能更新</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span> value=&#123;<span class="comment">/* 某个值 */</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>Class.contextType<ul>
<li>此属性可以让你使用 this.context 来获取最近 Context 上的值</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以在任何生命周期中访问到它，包括 render 函数中</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">        <span class="comment">/* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentDidUpdate</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="property">context</span>;</span><br><span class="line">        <span class="comment">/* 基于 MyContext 组件的值进行渲染 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property">contextType</span> = <span class="title class_">MyContext</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Context.Consumer</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传递给函数的 value 值等同于往上组件树离这个 context 最近的 Provider 提供的 value 值,没有Provider 就是createContext的defaultValue</span></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line">    &#123;<span class="function"><span class="params">value</span> =&gt;</span> <span class="comment">/* 基于 context 值进行渲染*/</span>&#125;</span><br><span class="line">&lt;/<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>Context.displayName<ul>
<li>context 对象接受 displayName 的 property，字符串类型。React DevTools 使用该字符串来确定 context 要显示的内容<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(<span class="comment">/* some value */</span>);</span><br><span class="line"><span class="title class_">MyContext</span>.<span class="property">displayName</span> = <span class="string">&#x27;MyDisplayName&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Provider</span>&gt; <span class="comment">// &quot;MyDisplayName.Provider&quot; 在 DevTools 中</span></span><br><span class="line">&lt;<span class="title class_">MyContext</span>.<span class="property">Consumer</span>&gt; <span class="comment">// &quot;MyDisplayName.Consumer&quot; 在 DevTools 中</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>动态 Context<ul>
<li>在嵌套组件中更新 Context(通过 context 传递一个函数，使得消费组件更新 context)<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保传递给 createContext 的默认值数据结构是调用组件能匹配的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">ThemeContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;</span><br><span class="line">  <span class="attr">theme</span>: themes.<span class="property">dark</span>,</span><br><span class="line">  <span class="attr">toggleTheme</span>: <span class="function">() =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用方</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ThemeTogglerButton</span>(<span class="params"></span>) &#123;</span><br><span class="line"><span class="comment">// Theme Toggler 按钮不仅仅只获取 theme 值，</span></span><br><span class="line"><span class="comment">// 它也从 context 中获取到一个 toggleTheme 函数</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">onClick</span>=<span class="string">&#123;toggleTheme&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">style</span>=<span class="string">&#123;&#123;backgroundColor:</span> <span class="attr">theme.background</span>&#125;&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">          Toggle Theme。。。</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      )&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>注意<ul>
<li><code>context</code> 根据引用标识决定何时渲染（本质上是 value 属性值的浅比较），陷阱：provider 父组件进行重渲染时，可能会在消费组件中触发意外的渲染<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每一次 Provider 重渲染时，value 属性总是被赋值为新的对象,会重新渲染下面所有的消费组件</span></span><br><span class="line"><span class="comment">// 改进：value 状态提升到父节点的 state </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">MyContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;something:</span> &#x27;<span class="attr">something</span>&#x27;&#125;&#125;&gt;</span> // value=&#123;this.state.value&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Toolbar</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">MyContext.Provider</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>错误边界<ul>
<li>为了解决：部分UI的js错误导致整个应用崩溃</li>
<li>它是React 组件，可以捕获并打印发生在其子组件树任何位置的js错误，会渲染出备用 UI，而不是渲染那些崩溃了的子组件树</li>
<li>在渲染期间、生命周期方法和整个组件树的构造函数中捕获错误</li>
<li>无法捕获的错误<ul>
<li>事件处理</li>
<li>异步代码（setTimeout 或 requestAnimationFrame 回调函数）</li>
<li>服务端渲染</li>
<li>它自身抛出来的错误（并非它的子组件）</li>
</ul>
</li>
<li>class 组件定义了 static getDerivedStateFromError() 或 componentDidCatch() 任意一个（或两个）时，它就变成一个错误边界<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新 state 使下一次渲染能够显示降级后的 UI</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, errorInfo</span>) &#123;</span><br><span class="line">    <span class="comment">// 你同样可以将错误日志上报给服务器</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, errorInfo);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以自定义降级后的 UI 并渲染</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>工作方式类似于js的 catch {}，不同于错误边界只针对 React 组件</li>
<li>只有 class 组件才可以成为错误边界组件。大多数情况下, 只需要声明一次错误边界组件, 可以在整个应用中使用它</li>
<li>可以包装在最顶层的路由组件展示一个 “Something went wrong” 的错误信息，就像服务端框架处理崩溃一样</li>
</ul>
</li>
</ul>
<h2 id="未捕获错误（Uncaught-Errors）的新行为"><a href="#未捕获错误（Uncaught-Errors）的新行为" class="headerlink" title="未捕获错误（Uncaught Errors）的新行为"></a>未捕获错误（Uncaught Errors）的新行为</h2><ul>
<li>任何未被错误边界捕获的错误将会导致整个 React 组件树被卸载</li>
</ul>
<h2 id="组件栈追踪"><a href="#组件栈追踪" class="headerlink" title="组件栈追踪"></a>组件栈追踪</h2><ul>
<li>渲染期间发生的所有错误打印到控制台,仅用于开发环境，<code>生产环境必须将其禁用</code></li>
<li>组件名称在栈追踪中的显示依赖于 Function.name 属性</li>
<li>如要支持 未提供该功能的旧版浏览器和设备（例如 IE 11），在打包（bundled）应用程序中包含一个 Function.name 的 polyfill（function.name-polyfill）或在所有组件上显式设置<br>displayName 属性</li>
</ul>
<h2 id="关于-try-x2F-catch"><a href="#关于-try-x2F-catch" class="headerlink" title="关于 try&#x2F;catch"></a>关于 try&#x2F;catch</h2><ul>
<li>仅用于命令式代码</li>
<li>错误边界无法捕获事件处理器内部的错误 使用try&#x2F;catch</li>
<li>错误边界保留了 React 的声明性质，例：即使错误发生在 componentDidUpdate 方法中，由某一个深层组件树的 setState 引起，仍然能冒泡到最近的错误边界</li>
</ul>
<h1 id="Refs"><a href="#Refs" class="headerlink" title="Refs"></a>Refs</h1><ul>
<li><p>Refs 可以<code>访问DOM节点</code>、<code>React元素</code></p>
</li>
<li><p>使用场景(勿过度使用)</p>
<ul>
<li>处理焦点，文本选择或媒体播放</li>
<li>触发强制动画</li>
<li>集成第三方DOM库</li>
</ul>
</li>
<li><p>创建 Refs</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React.create()创建，通过 ref 属性附加到元素上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;/</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>访问 Refs，节点的类型影响ref的取值</li>
<li>ref属性指向一个 DOM 元素或 class组件</li>
<li>不能在函数组件上使用ref属性，因为它没有实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyFunctionComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span>/&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">textInput</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// This will *not* work!</span></span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">MyFunctionComponent</span> <span class="attr">ref</span>=<span class="string">&#123;this.textInput&#125;/</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件中想使用ref,用下面forwardRef或转换为class组件</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在父组件中引用子节点的DOM节点，使用ref转发</li>
</ul>
<h2 id="转发-refs-到-DOM-组件"><a href="#转发-refs-到-DOM-组件" class="headerlink" title="转发 refs 到 DOM 组件"></a>转发 refs 到 DOM 组件</h2><ul>
<li>Ref 转发是一个可选特性，组件可以像暴露自己的ref一样暴露子组件的ref</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">FancyButton</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">className</span>=<span class="string">&quot;FancyButton&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以直接获取 DOM button 的 ref：</span></span><br><span class="line"><span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">FancyButton</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span>Click me!<span class="tag">&lt;/<span class="name">FancyButton</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="在高阶组件（HOC）中转发-refs"><a href="#在高阶组件（HOC）中转发-refs" class="headerlink" title="在高阶组件（HOC）中转发 refs"></a>在高阶组件（HOC）中转发 refs</h2><ul>
<li>ref 不是 属性,如果对 HOC 添加 ref，ref 会引用最外层的容器组件，而不是被包裹的组件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">LogProps</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">        <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;old props:&#x27;</span>, prevProps);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;new props:&#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123;forwardedRef, ...rest&#125; = <span class="variable language_">this</span>.<span class="property">props</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将自定义的 prop 属性 “forwardedRef” 定义为 ref</span></span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">ref</span>=<span class="string">&#123;forwardedRef&#125;</span> &#123;<span class="attr">...rest</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 React.forwardRef 回调的第二个参数 “ref”。</span></span><br><span class="line">    <span class="comment">// 将其作为常规 prop 属性传递给 LogProps，例如 “forwardedRef”</span></span><br><span class="line">    <span class="comment">// 然后它就可以被挂载到被 LogProps 包裹的子组件上。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">LogProps</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">forwardedRef</span>=<span class="string">&#123;ref&#125;/</span>&gt;</span></span>;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="回调-Refs"><a href="#回调-Refs" class="headerlink" title="回调 Refs"></a>回调 Refs</h2><ul>
<li>内联函数定义的 ref 回调,更新执行两次，第一次传参为null,第二次才是DOM元素<ul>
<li>因为每次渲染会创建新的函数实例，定义为class 绑定函数的方式可避免</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">CustomTextInput</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;props.inputRef&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Parent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="comment">// 传递一个函数，参数为DOM元素/组件实例</span></span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">CustomTextInput</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">                <span class="attr">inputRef</span>=<span class="string">&#123;el</span> =&gt;</span> this.inputElement = el&#125;</span></span><br><span class="line"><span class="language-xml">            /&gt;</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fragments"><a href="#Fragments" class="headerlink" title="Fragments"></a>Fragments</h1><ul>
<li>一个组件返回多个元素,Fragments 将子列表分组,不用向 DOM 添加额外节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Columns</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;props.items.map(item =&gt; (</span></span><br><span class="line"><span class="language-xml">                    // 没有`key`，React 会发出一个关键警告</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">React.Fragment</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">dt</span>&gt;</span>&#123;item.term&#125;<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">dd</span>&gt;</span>&#123;item.description&#125;<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                ))&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 没有map包含 可以短语法 &lt;&gt;&lt;/&gt; 不支持 key 或属性</span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><ul>
<li>基于 React 的组合特性而形成的设计模式</li>
<li>高阶组件是参数为组件，返回值为新组件的函数（组件转化为另一个组件）,纯函数</li>
<li>HOC 不会修改传入的组件，也不会使用继承来复制其行为</li>
</ul>
<h2 id="不要改变原始组件，使用组合"><a href="#不要改变原始组件，使用组合" class="headerlink" title="不要改变原始组件，使用组合"></a>不要改变原始组件，使用组合</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">InputComponent</span>) &#123;</span><br><span class="line">    <span class="title class_">InputComponent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">componentDidUpdate</span> = <span class="keyword">function</span> (<span class="params">prevProps</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous props: &#x27;</span>, prevProps);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 返回原始的 input 组件，暗示它已经被修改。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">InputComponent</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次调用 logProps 时，增强组件都会有 log 输出。</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">logProps</span>(<span class="title class_">InputComponent</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">logProps</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">        <span class="title function_">componentDidUpdate</span>(<span class="params">prevProps</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Current props: &#x27;</span>, <span class="variable language_">this</span>.<span class="property">props</span>);</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Previous props: &#x27;</span>, prevProps);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="comment">// 将 input 组件包装在容器中，而不对其进行修改。Good!</span></span><br><span class="line">            <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="将不相关的-props-传递给被包裹的组件"><a href="#将不相关的-props-传递给被包裹的组件" class="headerlink" title="将不相关的 props 传递给被包裹的组件"></a>将不相关的 props 传递给被包裹的组件</h2><ul>
<li>(HOC 应该透传与自身无关的 props)[<a target="_blank" rel="noopener" href="https://react.docschina.org/docs/higher-order-components.html]">https://react.docschina.org/docs/higher-order-components.html]</a></li>
</ul>
<h2 id="最大化可组合性"><a href="#最大化可组合性" class="headerlink" title="最大化可组合性"></a>最大化可组合性</h2><ul>
<li>最常见的HOC</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// React Redux 的 `connect` 函数</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComment</span> = <span class="title function_">connect</span>(commentSelector, commentActions)(<span class="title class_">CommentList</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// connect 是一个函数，它的返回值为另外一个函数。</span></span><br><span class="line"><span class="keyword">const</span> enhance = <span class="title function_">connect</span>(commentListSelector, commentListActions);</span><br><span class="line"><span class="comment">// 返回值为 HOC，它会返回已经连接 Redux store 的组件</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">ConnectedComment</span> = <span class="title function_">enhance</span>(<span class="title class_">CommentList</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="不要在-render-方法中使用-HOC"><a href="#不要在-render-方法中使用-HOC" class="headerlink" title="不要在 render 方法中使用 HOC"></a>不要在 render 方法中使用 HOC</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 每次调用 render 函数都会创建一个新的 EnhancedComponent</span></span><br><span class="line">    <span class="comment">// EnhancedComponent1 !== EnhancedComponent2</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">enhance</span>(<span class="title class_">MyComponent</span>);</span><br><span class="line">    <span class="comment">// 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！ </span></span><br><span class="line">    <span class="comment">// 重新挂载组件会导致该组件及其所有子组件的状态丢失</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">EnhancedComponent</span>/&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="务必复制静态方法"><a href="#务必复制静态方法" class="headerlink" title="务必复制静态方法"></a>务必复制静态方法</h2><ul>
<li>新组件没有原始组件的任何静态方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在返回之前把这些方法拷贝到容器组件上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enhance</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Enhance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;<span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须准确知道应该拷贝哪些方法 :(</span></span><br><span class="line">    <span class="title class_">Enhance</span>.<span class="property">staticMethod</span> = <span class="title class_">WrappedComponent</span>.<span class="property">staticMethod</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Enhance</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hoist-non-react-statics自动拷贝所有非 React 静态方法</span></span><br><span class="line"><span class="keyword">import</span> hoistNonReactStatic <span class="keyword">from</span> <span class="string">&#x27;hoist-non-react-statics&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">enhance</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Enhance</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;<span class="comment">/*...*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">hoistNonReactStatic</span>(<span class="title class_">Enhance</span>, <span class="title class_">WrappedComponent</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Enhance</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="与第三方库协同"><a href="#与第三方库协同" class="headerlink" title="与第三方库协同"></a>与第三方库协同</h1><ul>
<li>React 不会理会 React 自身之外的 DOM 操作</li>
<li>它根据内部虚拟 DOM 来决定是否需要更新，如果同一个 DOM 节点被另一个库操作了，React 会觉得困惑而且没有办法恢复</li>
<li>避免冲突的最简单方式就是防止 React 组件更新（渲染无需更新的 React 元素，比如一个空的 <div />）</li>
</ul>
<h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="使用生产版本"><a href="#使用生产版本" class="headerlink" title="使用生产版本"></a>使用生产版本</h2><h2 id="虚拟化长列表"><a href="#虚拟化长列表" class="headerlink" title="虚拟化长列表"></a>虚拟化长列表</h2><ul>
<li>应用渲染长列表（上百甚至上千的数据）使用“虚拟滚动”</li>
<li>热门的虚拟滚动库：<a target="_blank" rel="noopener" href="https://react-window.vercel.app/#/examples/list/fixed-size">react-window</a><br>和 <a target="_blank" rel="noopener" href="https://bvaughn.github.io/react-virtualized/">react-virtualized</a></li>
</ul>
<h2 id="避免调停"><a href="#避免调停" class="headerlink" title="避免调停"></a>避免调停</h2><ul>
<li>组件的<code>props</code>或<code>state</code>变更，React会将最新返回的元素与之前渲染的元素对比，决定是否有必要更新真实的 DOM。如不相同，React 会更新该 DOM</li>
<li>React 只更新改变了的 DOM 节点，重新渲染仍然花费一些时间，如果很慢，可用<code>shouldComponentUpdate</code>提速,该方法会在重新渲染前被触发</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认实现总是返回 true</span></span><br><span class="line"><span class="comment">// 知道在什么情况下组件不需要更新，可以在 shouldComponentUpdate 中返回 false 跳过整个渲染过程</span></span><br><span class="line"><span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>大部分情况可以继承 <code>React.PureComponent</code> 以代替手写 shouldComponentUpdate()</li>
</ul>
<h2 id="shouldComponentUpdate-的作用"><a href="#shouldComponentUpdate-的作用" class="headerlink" title="shouldComponentUpdate 的作用"></a>shouldComponentUpdate 的作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CounterButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 props.color 或者 state.count 的值改变才需要更新</span></span><br><span class="line">    <span class="title function_">shouldComponentUpdate</span>(<span class="params">nextProps, nextState</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">color</span> !== nextProps.<span class="property">color</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> !== nextState.<span class="property">count</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个代替上面，仅做对象的浅比较，无法检查深层差别</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CounterButton</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.PureComponent</span> &#123;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 仅是简单对比</span></span><br><span class="line"><span class="comment">// 问题：state中 words: [&#x27;marklar&#x27;] 变成 [&#x27;marklar&#x27;,&#x27;marklar&#x27;] 比较结果相同 并不会更新</span></span><br></pre></td></tr></table></figure>

<ul>
<li>避免上面问题：改变指针</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleClick</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        <span class="attr">words</span>: [...state.<span class="property">words</span>, <span class="string">&#x27;marklar&#x27;</span>],</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">updateColorMap</span>(<span class="params">colormap</span>) &#123;</span><br><span class="line">    colormap.<span class="property">right</span> = <span class="string">&#x27;blue&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 改为</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateColorMap</span>(<span class="params">colormap</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, colormap, &#123;<span class="attr">right</span>: <span class="string">&#x27;blue&#x27;</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Portals"><a href="#Portals" class="headerlink" title="Portals"></a>Portals</h1><ul>
<li>将子节点渲染到父组件以外的DOM节点</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, container)</span><br><span class="line"><span class="comment">// child 任何可渲染的react子元素</span></span><br><span class="line"><span class="comment">// container DOM元素</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// React 挂载了一个新的 div，并且把子元素渲染其中</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;this.props.children&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="title function_">render</span>(<span class="params"></span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// React 并没有创建一个新的 div。它只是把子元素渲染到 `domNode` 中。</span></span><br><span class="line">    <span class="comment">// `domNode` 是一个可以在任何位置的有效 DOM 节点。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>,</span><br><span class="line">        domNode</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>应用：父组件有 <code>overflow: hidden</code>或 <code>z-index</code> 需要在视觉上跳出容器</li>
<li>portal 存在于 React 树， 且与 DOM 树 中的位置无关</li>
<li>从 portal 内部触发的事件会一直冒泡至包含 React 树的祖先，即便这些元素并不是 DOM 树 中的祖先</li>
</ul>
<h1 id="Profiler"><a href="#Profiler" class="headerlink" title="Profiler"></a>Profiler</h1><ul>
<li>可以添加在 React 树中的任何地方测量树中这部分渲染所带来的开销</li>
<li>两个prop： id(组件)、组件更新被调用的回调函数</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">App</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Profiler</span> <span class="attr">id</span>=<span class="string">&quot;Navigation&quot;</span> <span class="attr">onRender</span>=<span class="string">&#123;callback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Navigation</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Profiler</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Profiler</span> <span class="attr">id</span>=<span class="string">&quot;Main&quot;</span> <span class="attr">onRender</span>=<span class="string">&#123;callback&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">Main</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">Profiler</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">App</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="回调参数"><a href="#回调参数" class="headerlink" title="回调参数"></a>回调参数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">onRenderCallback</span>(<span class="params"></span></span><br><span class="line"><span class="params">    id, <span class="comment">// 监听的组件</span></span></span><br><span class="line"><span class="params">    phase, <span class="comment">// &quot;mount&quot; | &quot;update&quot; 来判断造成组件重渲染的原因（第一次、props、state、hooks引起）</span></span></span><br><span class="line"><span class="params">    actualDuration, <span class="comment">// 本次更新在渲染Profiler和子代上花费的时间，理想情况：子代因特定的prop改变而重渲染，值在第一次之后下降</span></span></span><br><span class="line"><span class="params">    baseDuration, <span class="comment">// </span></span></span><br><span class="line"><span class="params">    startTime, <span class="comment">// 本次更新中 React 开始渲染的时间戳。</span></span></span><br><span class="line"><span class="params">    commitTime, <span class="comment">// </span></span></span><br><span class="line"><span class="params">    interactions <span class="comment">// 本次更新交互的集合</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 合计或记录渲染时间。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="没有使用ES6"><a href="#没有使用ES6" class="headerlink" title="没有使用ES6"></a>没有使用ES6</h2><ul>
<li>class 关键字定义组件，还可以使用 <code>create-react-class</code> 模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createReactClass = <span class="built_in">require</span>(<span class="string">&#x27;create-react-class&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeting</span> = <span class="title function_">createReactClass</span>(&#123;</span><br><span class="line">    <span class="attr">render</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>函数组件和class组件，都有defaultProps属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Greeting</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用模块创建</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Greeting</span> = <span class="title function_">createReactClass</span>(&#123;</span><br><span class="line">    <span class="attr">getDefaultProps</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">name</span>: <span class="string">&#x27;Mary&#x27;</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化 state</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>(props);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">state</span> = &#123;<span class="attr">count</span>: props.<span class="property">initialCount</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getInitialState方法</span></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">Counter</span> = <span class="title function_">createReactClass</span>(&#123;</span><br><span class="line">    <span class="attr">getInitialState</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">initialCount</span>&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>createReactClass()创建组件，方法自动绑定到实例不需要在constructor中.bind(this)</li>
</ul>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><ul>
<li>es6本身不包含任何 <code>mixin</code>  ，class组件不支持</li>
<li>mixins（js对象：通过它封装通用的函数） 调用在组件之前</li>
<li></li>
</ul>
<h1 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h1><h2 id="Diffing-算法"><a href="#Diffing-算法" class="headerlink" title="Diffing 算法"></a>Diffing 算法</h2><ul>
<li><code>对比不同类型的元素</code>：根结点为不同类型元素时，React会拆卸原有的树建起新的树。根节点以下的组件也会被卸载，它们的状态会被销毁</li>
<li><code>对比同一类型的元素</code>：会保留DOM节点，仅对比更新有改变的属性</li>
<li><code>对比同类型的组件元素</code>：组件实例不变，更新组件实例的props 跟 最新的元素保持一致</li>
<li><code>对子节点进行递归</code>：递归DOM节点的子元素时，React会同时遍历两个子元素列表，产生差异时，生成一个mutation</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配完前两个最后插入第三个</span></span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>first<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>second<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>third<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="comment">// 插入头部会很影响性能，开销变大</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>keys</code>：为了解决以上消耗性能，React使用key匹配原有树上的子元素与最新树上的子元素<ul>
<li>避免使用index，有顺序修改，diff变慢</li>
</ul>
</li>
</ul>
<h1 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h1><ul>
<li>用于告知组件需要渲染什么内容的函数prop</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 追逐鼠标</span></span><br><span class="line">... <span class="comment">//Cat</span></span><br><span class="line"><span class="keyword">const</span> mouse = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">mouse</span>;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/cat.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&#123;&#123;position:</span> &#x27;<span class="attr">absolute</span>&#x27;, <span class="attr">left:</span> <span class="attr">mouse.x</span>, <span class="attr">top:</span> <span class="attr">mouse.y</span>&#125;&#125;/&gt;</span></span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//  封装Mouse记录鼠标移动,</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">)&#125;/&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果你出于某种原因真的想要 HOC，那么你可以轻松实现</span></span><br><span class="line"><span class="comment">// 使用具有 render prop 的普通组件创建一个！</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">withMouse</span>(<span class="params">Component</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">        <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (</span><br><span class="line">                <span class="language-xml"><span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;mouse</span> =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                )&#125;/&gt;</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不必使用render也可以</span></span><br><span class="line">&lt;<span class="title class_">Mouse</span> children=&#123;<span class="function"><span class="params">mouse</span> =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line">)&#125;/&gt;</span><br><span class="line"><span class="comment">// 直接放到元素内部也可以</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">Mouse</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;mouse =&gt; (</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>鼠标的位置是 &#123;mouse.x&#125;，&#123;mouse.y&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    )&#125;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">Mouse</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>Render Props</code>与<code>React.PureComponent</code> 避免一起使用，每一个 render 对于render prop总会生成新值，浅比较props的时候总会是false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MouseTracker</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="comment">// 定义为实例方法，`this.renderTheCat`</span></span><br><span class="line">    <span class="comment">// 在渲染中使用它时，它指的是相同的函数</span></span><br><span class="line">    <span class="title function_">renderTheCat</span>(<span class="params">mouse</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Cat</span> <span class="attr">mouse</span>=<span class="string">&#123;mouse&#125;/</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                <span class="tag">&lt;<span class="name">Mouse</span> <span class="attr">render</span>=<span class="string">&#123;this.renderTheCat&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h1><ul>
<li>运行前识别类型问题，使用 <code>Flow</code> 或 <code>TypeScript</code> 来代替 <code>PropTypes</code></li>
</ul>
<h2 id="Flow"><a href="#Flow" class="headerlink" title="Flow"></a>Flow</h2><ul>
<li>通过类型注释的特殊语法 扩展js，浏览器解析不了这种语法</li>
<li>编译后的代码去除 Flow 语法</li>
</ul>
<h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><ul>
<li>在<code>tsconfig.json</code>中定义配置项</li>
<li>.tsx 包含 JSX 代码的 ts文件</li>
</ul>
<h2 id="类型定义"><a href="#类型定义" class="headerlink" title="类型定义"></a>类型定义</h2><ul>
<li>判断一个库是否包含类型，<code>index.d.ts</code> 或者 package.json 文件的 <code>typings</code> 或 <code>types</code> 属性中指定类型文件</li>
<li><code>DefinitelyTyped</code> 为没有声明文件的js库提供类型定义</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yarn</span></span><br><span class="line">yarn</span><br><span class="line">add--</span><br><span class="line">dev</span><br><span class="line">@types/</span><br><span class="line">react</span><br></pre></td></tr></table></figure>

<ul>
<li>局部声明：使用的包里没有声明文件，在 DefinitelyTyped 上也没有，创建本地定义文件，根目录declarations.d.ts 文件</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">declare</span><br><span class="line"><span class="variable language_">module</span></span><br><span class="line"><span class="string">&#x27;querystring&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">stringify</span>(<span class="params">val: object</span>): string</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">parse</span>(<span class="params">val: string</span>): object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h1><ul>
<li><code>StrictMode</code> 显示应用程序中潜在问题的工具，不会渲染任何可见的 UI。它为其后代元素触发额外的检查和警告</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">React</span>.<span class="property">StrictMode</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ComponentOne</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ComponentTwo</span>/&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">React</span>.<span class="property">StrictMode</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="识别不安全的生命周期"><a href="#识别不安全的生命周期" class="headerlink" title="识别不安全的生命周期"></a>识别不安全的生命周期</h2><h2 id="使用过时字符串-ref-API-的警告"><a href="#使用过时字符串-ref-API-的警告" class="headerlink" title="使用过时字符串 ref API 的警告"></a>使用过时字符串 ref API 的警告</h2><ul>
<li>createRef方式会警告，回调 ref 依旧适用</li>
</ul>
<h2 id="使用废弃的-findDOMNode-方法的警告"><a href="#使用废弃的-findDOMNode-方法的警告" class="headerlink" title="使用废弃的 findDOMNode 方法的警告"></a>使用废弃的 findDOMNode 方法的警告</h2><ul>
<li>只读一次的 API：调用只会返回第一次查询的结果。子组件渲染不同的节点，无法跟踪更改</li>
<li>findDOMNode使父组件需要单独渲染子组件，产生重构；</li>
<li>仅在组件返回单个且不可变的 DOM节点才有效</li>
<li>ref传递、转发</li>
</ul>
<h2 id="检测意外的副作用"><a href="#检测意外的副作用" class="headerlink" title="检测意外的副作用"></a>检测意外的副作用</h2><ul>
<li>React 工作的两个阶段<ul>
<li>渲染：确定进行的更改（新旧DOM树对比）</li>
<li>渲染阶段的声明周期可能会被多次调用<ul>
<li>constructor</li>
<li>componentWillMount (or UNSAFE_componentWillMount)</li>
<li>componentWillReceiveProps (or UNSAFE_componentWillReceiveProps)</li>
<li>componentWillUpdate (or UNSAFE_componentWillUpdate)</li>
<li>getDerivedStateFromProps</li>
<li>shouldComponentUpdate</li>
<li>render</li>
<li>setState 更新函数（第一个参数）</li>
</ul>
</li>
<li>提交：React 应用变化时（React DOM插入、更新、删除节点）调用生命周期方法</li>
</ul>
</li>
</ul>
<h2 id="检测过时的-context-API"><a href="#检测过时的-context-API" class="headerlink" title="检测过时的 context API"></a>检测过时的 context API</h2><h1 id="使用-PropTypes-进行类型检查"><a href="#使用-PropTypes-进行类型检查" class="headerlink" title="使用 PropTypes 进行类型检查"></a>使用 PropTypes 进行类型检查</h1><ul>
<li>限制单个元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 这必须只有一个元素，否则控制台会打印警告。</span></span><br><span class="line">        <span class="keyword">const</span> children = <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                &#123;children&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="title class_">PropTypes</span>.<span class="property">element</span>.<span class="property">isRequired</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>默认 Prop 值<ul>
<li>类型检查适用 defaultProps，发生在它赋值后</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;stranger&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (</span><br><span class="line">            <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="title class_">Greeting</span>.<span class="property">defaultProps</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Stranger&#x27;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h1><ul>
<li>受控组件：表单数据React组件管理</li>
<li>非受控组件：表单数据由DOM节点处理（ref操作）</li>
<li>默认值</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">   defaultValue=<span class="string">&quot;Bob&quot;</span></span><br><span class="line">   type=<span class="string">&quot;text&quot;</span></span><br><span class="line">   ref=&#123;<span class="variable language_">this</span>.<span class="property">input</span>&#125;/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;input type=&quot;file&quot;/&gt;</code> 始终是一个非受控组件</li>
</ul>
<h1 id="Web-Components"><a href="#Web-Components" class="headerlink" title="Web Components"></a>Web Components</h1><ul>
<li>为可复用组件提供了强大的封装，而 React 提供了声明式的解决方案，使 DOM 与数据保持同步</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">XSearch</span> <span class="keyword">extends</span> <span class="title class_ inherited__">HTMLElement</span> &#123;</span><br><span class="line">    <span class="title function_">connectedCallback</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> mountPoint = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;span&#x27;</span>);</span><br><span class="line">        <span class="variable language_">this</span>.<span class="title function_">attachShadow</span>(&#123;<span class="attr">mode</span>: <span class="string">&#x27;open&#x27;</span>&#125;).<span class="title function_">appendChild</span>(mountPoint);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> name = <span class="variable language_">this</span>.<span class="title function_">getAttribute</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line">        <span class="keyword">const</span> url = <span class="string">&#x27;https://www.google.com/search?q=&#x27;</span> + <span class="built_in">encodeURIComponent</span>(name);</span><br><span class="line">        <span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#123;url&#125;</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>, mountPoint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册自定义元素</span></span><br><span class="line">customElements.<span class="title function_">define</span>(<span class="string">&#x27;x-search&#x27;</span>, <span class="title class_">XSearch</span>);</span><br></pre></td></tr></table></figure>
</article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/React/">React</a></div><div class="post_share"><div class="social-share" data-image="https://byblog.oss-cn-hangzhou.aliyuncs.com/4.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2019/05/03/react/React%20-%20Hooks/"><img class="prev-cover" src="https://byblog.oss-cn-hangzhou.aliyuncs.com/2.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">React - Hooks</div></div></a></div><div class="next-post pull-right"><a href="/2019/05/01/react/React%20-%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"><img class="next-cover" src="https://byblog.oss-cn-hangzhou.aliyuncs.com/3.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">React - 核心概念</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2019/05/01/react/React%20-%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" title="React - 核心概念"><img class="cover" src="https://byblog.oss-cn-hangzhou.aliyuncs.com/3.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-01</div><div class="title">React - 核心概念</div></div></a></div><div><a href="/2019/05/05/react/React%20-%20Api/" title="React - Api"><img class="cover" src="https://byblog.oss-cn-hangzhou.aliyuncs.com/1.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-05</div><div class="title">React - Api</div></div></a></div><div><a href="/2019/05/03/react/React%20-%20Hooks/" title="React - Hooks"><img class="cover" src="https://byblog.oss-cn-hangzhou.aliyuncs.com/2.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-05-03</div><div class="title">React - Hooks</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2"><span class="toc-text">代码分割</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85"><span class="toc-text">打包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2-1"><span class="toc-text">代码分割</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#React-lazy"><span class="toc-text">React.lazy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E8%B7%AF%E7%94%B1%E7%9A%84%E4%BB%A3%E7%A0%81%E5%88%86%E5%89%B2"><span class="toc-text">基于路由的代码分割</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Context"><span class="toc-text">Context</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E7%94%A8-Context"><span class="toc-text">何时用 Context</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#API"><span class="toc-text">API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E6%8D%95%E8%8E%B7%E9%94%99%E8%AF%AF%EF%BC%88Uncaught-Errors%EF%BC%89%E7%9A%84%E6%96%B0%E8%A1%8C%E4%B8%BA"><span class="toc-text">未捕获错误（Uncaught Errors）的新行为</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%A0%88%E8%BF%BD%E8%B8%AA"><span class="toc-text">组件栈追踪</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-try-x2F-catch"><span class="toc-text">关于 try&#x2F;catch</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Refs"><span class="toc-text">Refs</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E5%8F%91-refs-%E5%88%B0-DOM-%E7%BB%84%E4%BB%B6"><span class="toc-text">转发 refs 到 DOM 组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%EF%BC%88HOC%EF%BC%89%E4%B8%AD%E8%BD%AC%E5%8F%91-refs"><span class="toc-text">在高阶组件（HOC）中转发 refs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83-Refs"><span class="toc-text">回调 Refs</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fragments"><span class="toc-text">Fragments</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">高阶组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E6%94%B9%E5%8F%98%E5%8E%9F%E5%A7%8B%E7%BB%84%E4%BB%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88"><span class="toc-text">不要改变原始组件，使用组合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E4%B8%8D%E7%9B%B8%E5%85%B3%E7%9A%84-props-%E4%BC%A0%E9%80%92%E7%BB%99%E8%A2%AB%E5%8C%85%E8%A3%B9%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-text">将不相关的 props 传递给被包裹的组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%8C%96%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7"><span class="toc-text">最大化可组合性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E5%9C%A8-render-%E6%96%B9%E6%B3%95%E4%B8%AD%E4%BD%BF%E7%94%A8-HOC"><span class="toc-text">不要在 render 方法中使用 HOC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A1%E5%BF%85%E5%A4%8D%E5%88%B6%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-text">务必复制静态方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%8E%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E5%8D%8F%E5%90%8C"><span class="toc-text">与第三方库协同</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%94%9F%E4%BA%A7%E7%89%88%E6%9C%AC"><span class="toc-text">使用生产版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E9%95%BF%E5%88%97%E8%A1%A8"><span class="toc-text">虚拟化长列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E8%B0%83%E5%81%9C"><span class="toc-text">避免调停</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shouldComponentUpdate-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">shouldComponentUpdate 的作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Portals"><span class="toc-text">Portals</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Profiler"><span class="toc-text">Profiler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9E%E8%B0%83%E5%8F%82%E6%95%B0"><span class="toc-text">回调参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E4%BD%BF%E7%94%A8ES6"><span class="toc-text">没有使用ES6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mixins"><span class="toc-text">Mixins</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8D%8F%E8%B0%83"><span class="toc-text">协调</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Diffing-%E7%AE%97%E6%B3%95"><span class="toc-text">Diffing 算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Render-Props"><span class="toc-text">Render Props</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-text">静态类型检查</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Flow"><span class="toc-text">Flow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TypeScript"><span class="toc-text">TypeScript</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">类型定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">严格模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%86%E5%88%AB%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-text">识别不安全的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%87%E6%97%B6%E5%AD%97%E7%AC%A6%E4%B8%B2-ref-API-%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-text">使用过时字符串 ref API 的警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BA%9F%E5%BC%83%E7%9A%84-findDOMNode-%E6%96%B9%E6%B3%95%E7%9A%84%E8%AD%A6%E5%91%8A"><span class="toc-text">使用废弃的 findDOMNode 方法的警告</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E6%84%8F%E5%A4%96%E7%9A%84%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-text">检测意外的副作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E8%BF%87%E6%97%B6%E7%9A%84-context-API"><span class="toc-text">检测过时的 context API</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-PropTypes-%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="toc-text">使用 PropTypes 进行类型检查</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E5%8F%97%E6%8E%A7%E7%BB%84%E4%BB%B6"><span class="toc-text">非受控组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Web-Components"><span class="toc-text">Web Components</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://byblog.oss-cn-hangzhou.aliyuncs.com/4.jpeg')"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2022 By 刘俊宏</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"></div><div id="rightside-config-show"><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script></div></body></html>